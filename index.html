<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Minecraft 3D</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;overflow:hidden;font-family:'Press Start 2P',monospace;user-select:none}
#c{display:block;width:100vw;height:100vh;touch-action:none}

/* HUD */
#hud{position:fixed;top:0;left:0;right:0;display:flex;justify-content:space-between;padding:8px 12px;pointer-events:none;z-index:10}
.panel{background:rgba(0,0,0,0.65);border:2px solid rgba(255,255,255,0.12);padding:6px 10px;color:#fff;font-size:6px;line-height:2}
.pt{color:#7EC850;font-size:7px;margin-bottom:2px}

/* Crosshair */
#xhair{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);pointer-events:none;z-index:10;color:#fff;font-size:20px;text-shadow:0 0 4px #000;line-height:1}

/* Mode bar */
#modebar{position:fixed;top:50%;right:12px;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:10;pointer-events:all}
.modeBtn{font-family:'Press Start 2P',monospace;font-size:6px;padding:6px 8px;background:rgba(0,0,0,0.7);border:2px solid #444;color:#888;cursor:pointer;white-space:nowrap}
.modeBtn.active{border-color:#FFD700;color:#FFD700;background:rgba(40,30,0,0.85)}

/* Mining progress */
#mineBar{position:fixed;top:52%;left:50%;transform:translate(-50%,16px);width:120px;height:8px;background:rgba(0,0,0,0.6);border:2px solid #888;z-index:10;display:none;pointer-events:none}
#mineFill{height:100%;background:#FFD700;width:0%;transition:width 0.05s}

/* Hotbar */
#hotbar{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:3px;z-index:10;pointer-events:all;background:rgba(0,0,0,0.75);border:2px solid rgba(255,255,255,0.2);padding:4px}
.slot{width:48px;height:48px;border:2px solid #555;background:#1a1a1a;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;position:relative;flex-shrink:0}
.slot.active{border-color:#FFD700;box-shadow:0 0 8px rgba(255,215,0,0.5)}
.slot:hover{border-color:#aaa}
.slot-icon{font-size:18px;line-height:1}
.slot-count{position:absolute;bottom:2px;right:4px;font-size:5px;color:#FFD700}
.slot-key{position:absolute;top:2px;left:3px;font-size:5px;color:#555}

/* Hearts */
#hp{position:fixed;bottom:78px;left:50%;transform:translateX(-50%);display:flex;gap:2px;z-index:10;pointer-events:none}
.heart{font-size:11px}

/* Toast */
#toast{position:fixed;top:50px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.85);border:2px solid #7EC850;color:#7EC850;font-size:7px;padding:6px 12px;z-index:20;display:none;white-space:nowrap;pointer-events:none}

/* Inventory */
#inventory{position:fixed;inset:0;background:rgba(0,0,0,0.75);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:30}
.inv-panel{background:#333;border:3px solid #555;padding:16px;display:flex;flex-direction:column;gap:12px;min-width:340px}
.inv-title{color:#FFD700;font-size:9px;text-align:center;margin-bottom:4px}
.inv-grid{display:grid;grid-template-columns:repeat(9,40px);gap:3px}
.inv-slot{width:40px;height:40px;border:2px solid #555;background:#1a1a1a;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;position:relative;font-size:16px}
.inv-slot:hover{border-color:#aaa}
.inv-slot.dragging-over{border-color:#FFD700}
.inv-count{position:absolute;bottom:1px;right:3px;font-size:5px;color:#FFD700}
#closeInv{font-family:'Press Start 2P',monospace;font-size:7px;padding:6px 14px;background:#444;border:2px solid #666;color:#ccc;cursor:pointer;align-self:center}
#closeInv:hover{border-color:#aaa;color:#fff}

/* Crafting */
#crafting{position:fixed;inset:0;background:rgba(0,0,0,0.8);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:35}
.craft-panel{background:#333;border:3px solid #777;padding:16px;display:flex;flex-direction:column;gap:10px;width:360px}
.craft-title{color:#7EC850;font-size:9px;text-align:center}
.craft-grid{display:grid;grid-template-columns:repeat(2,60px);gap:4px;margin:0 auto}
.craft-slot{width:60px;height:50px;border:2px solid #666;background:#1a1a1a;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:20px;position:relative;cursor:default}
.craft-slot .craft-label{font-size:5px;color:#888;margin-top:2px}
.recipes-list{display:flex;flex-direction:column;gap:4px;max-height:240px;overflow-y:auto}
.recipe-row{display:flex;align-items:center;gap:8px;padding:5px 6px;border:2px solid #555;background:#222;cursor:pointer}
.recipe-row:hover{border-color:#7EC850;background:#1a2a1a}
.recipe-row.disabled{opacity:0.4;cursor:not-allowed}
.recipe-icon{font-size:18px;width:26px;text-align:center}
.recipe-info{flex:1}
.recipe-name{font-size:6px;color:#fff}
.recipe-cost{font-size:5px;color:#aaa;margin-top:2px}
.recipe-result{font-size:6px;color:#FFD700;margin-left:auto}
#closeCraft{font-family:'Press Start 2P',monospace;font-size:7px;padding:6px 14px;background:#444;border:2px solid #666;color:#ccc;cursor:pointer;align-self:center}

/* Start / Death screens */
#blocker{position:fixed;inset:0;background:rgba(0,0,0,0.85);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:50;gap:14px;color:#fff}
#blocker h1{font-size:18px;color:#7EC850;text-shadow:3px 3px #000}
#blocker p{font-size:6.5px;color:#bbb;line-height:2.4;text-align:center;max-width:380px}
#startBtn{font-family:'Press Start 2P',monospace;font-size:10px;padding:14px 28px;background:#5D8A35;border:3px solid #7EC850;color:#fff;cursor:pointer;box-shadow:4px 4px #000}
#startBtn:hover{background:#6fa040}
#deathScreen{position:fixed;inset:0;background:rgba(160,0,0,0.6);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:60;gap:12px;color:#fff}
#deathScreen h2{font-size:16px;color:#ff5555;text-shadow:2px 2px #000}
#respawnBtn{font-family:'Press Start 2P',monospace;font-size:9px;padding:10px 22px;background:#8B3A2A;border:3px solid #ff5555;color:#fff;cursor:pointer}

/* Hit flash */
#dmgFlash{position:fixed;inset:0;pointer-events:none;z-index:9;border:6px solid rgba(255,0,0,0);transition:border-color 0.1s}
#dmgFlash.flash{border-color:rgba(255,0,0,0.5)}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="xhair">+</div>
<div id="dmgFlash"></div>

<div id="hud">
  <div class="panel">
    <div class="pt">â› MINECRAFT 3D</div>
    <div id="pos">0/0/0</div>
    <div id="look">â€”</div>
    <div id="fps">â€”</div>
  </div>
  <div class="panel">
    <div class="pt">KEYS</div>
    <div>WASD/â†‘â†“â†â†’ Move</div>
    <div>SPACE Jump</div>
    <div>E Inventory</div>
    <div>C Crafting</div>
    <div>F Mode toggle</div>
    <div>LMB Mine/Fight/Place</div>
    <div>RMB Place/Eat food</div>
    <div>R Eat held food</div>
  </div>
</div>

<!-- Mode selector -->
<div id="modebar">
  <button class="modeBtn active" onclick="setMode('mine')" id="mode-mine">â› MINE</button>
  <button class="modeBtn" onclick="setMode('fight')" id="mode-fight">âš” FIGHT</button>
  <button class="modeBtn" onclick="setMode('build')" id="mode-build">ğŸ§± BUILD</button>
</div>

<div id="mineBar"><div id="mineFill"></div></div>
<div id="hp"></div>
<div id="hotbar"></div>
<div id="toast"></div>

<!-- Inventory -->
<div id="inventory">
  <div class="inv-panel">
    <div class="inv-title">ğŸ’ INVENTORY</div>
    <div style="font-size:5px;color:#aaa;text-align:center;margin-bottom:4px">Left-click item â†’ hotbar &nbsp;|&nbsp; Right-click food â†’ eat</div>
    <div class="inv-grid" id="invGrid"></div>
    <button id="closeInv" onclick="closeInv()">Close (E)</button>
  </div>
</div>

<!-- Crafting -->
<div id="crafting">
  <div class="craft-panel">
    <div class="craft-title">ğŸ”¨ CRAFTING TABLE</div>
    <div class="recipes-list" id="recipesList"></div>
    <button id="closeCraft" onclick="closeCraft()">Close (C)</button>
  </div>
</div>

<!-- Start -->
<div id="blocker">
  <h1>MINECRAFT 3D</h1>
  <p>â› MINE blocks Â· âš” FIGHT mobs Â· ğŸ§± BUILD structures<br><br>
  Move mouse to look Â· WASD to move Â· SPACE jump<br>
  LMB = action (mine/fight/place) Â· RMB = always place<br>
  F = switch mode Â· E = inventory Â· C = crafting table</p>
  <button id="startBtn" onclick="startGame()">â–¶ PLAY</button>
</div>

<div id="deathScreen">
  <h2>YOU DIED!</h2>
  <p style="font-size:6px;color:#ffaaaa">Killed by a Zombie</p>
  <button id="respawnBtn" onclick="respawn()">Respawn</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ITEMS & BLOCKS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ITEMS={
  // Placeable blocks
  grass:  {name:'Grass',  icon:'ğŸŸ©', block:0, stackSize:64},
  dirt:   {name:'Dirt',   icon:'ğŸŸ«', block:1, stackSize:64},
  stone:  {name:'Stone',  icon:'â¬›', block:2, stackSize:64},
  wood:   {name:'Wood',   icon:'ğŸªµ', block:3, stackSize:64},
  leaves: {name:'Leaves', icon:'ğŸŒ¿', block:4, stackSize:64},
  sand:   {name:'Sand',   icon:'ğŸŸ¨', block:5, stackSize:64},
  brick:  {name:'Brick',  icon:'ğŸ§±', block:6, stackSize:64},
  snow:   {name:'Snow',   icon:'â„ï¸', block:7, stackSize:64},
  // Non-block items
  cobble: {name:'Cobble', icon:'ğŸª¨', block:2, stackSize:64}, // alias for stone drop
  stick:  {name:'Stick',  icon:'ğŸ¥¢', block:-1, stackSize:64},
  plank:  {name:'Plank',  icon:'ğŸ“‹', block:-1, stackSize:64},
  sword:  {name:'Sword',  icon:'âš”ï¸',  block:-1, stackSize:1, dmg:5},
  pickaxe:{name:'Pickaxe',icon:'â›ï¸',  block:-1, stackSize:1, mineSpeed:3},
  axe:    {name:'Axe',    icon:'ğŸª“',  block:-1, stackSize:1, mineSpeed:2.5},
  torch:  {name:'Torch',  icon:'ğŸ”¦',  block:-1, stackSize:64},
  meat:   {name:'Meat',   icon:'ğŸ¥©',  block:-1, stackSize:16, heal:4},
  bone:   {name:'Bone',   icon:'ğŸ¦´',  block:-1, stackSize:16},
  feather:{name:'Feather',icon:'ğŸª¶',  block:-1, stackSize:16},
};

// Block definitions (index matches BDEFS array order)
const BDEFS=[
  {id:'grass', name:'Grass', drop:'dirt',   hardness:0.6, colors:['#8B5E3C','#8B5E3C','#6dbf3f','#7A5230','#8B5E3C','#8B5E3C']},
  {id:'dirt',  name:'Dirt',  drop:'dirt',   hardness:0.5, colors:['#7A5230','#7A5230','#8B5E3C','#6B4226','#7A5230','#7A5230']},
  {id:'stone', name:'Stone', drop:'cobble', hardness:1.5, colors:['#777','#777','#888','#666','#777','#777']},
  {id:'wood',  name:'Wood',  drop:'wood',   hardness:1.2, colors:['#8B6914','#8B6914','#A07830','#A07830','#8B6914','#8B6914']},
  {id:'leaves',name:'Leaves',drop:null,     hardness:0.2, colors:['#2D6A1F','#2D6A1F','#3A8A28','#245A18','#2D6A1F','#2D6A1F']},
  {id:'sand',  name:'Sand',  drop:'sand',   hardness:0.5, colors:['#D4B96A','#D4B96A','#E0C878','#C4A85A','#D4B96A','#D4B96A']},
  {id:'brick', name:'Brick', drop:'brick',  hardness:2.0, colors:['#8B3A2A','#8B3A2A','#9B4A3A','#7A2A1A','#8B3A2A','#8B3A2A']},
  {id:'snow',  name:'Snow',  drop:'snow',   hardness:0.2, colors:['#E8EEF0','#E8EEF0','#F5F8FA','#D8E4EA','#E8EEF0','#E8EEF0']},
];

// Crafting recipes: {result, count, ingredients:{itemId:amount}}
const RECIPES=[
  {result:'plank',  count:4, ingredients:{wood:1},        label:'Wood â†’ 4 Planks'},
  {result:'stick',  count:4, ingredients:{plank:2},        label:'2 Planks â†’ 4 Sticks'},
  {result:'sword',  count:1, ingredients:{plank:1,stick:2},label:'Plank + 2 Sticks â†’ Sword'},
  {result:'pickaxe',count:1, ingredients:{cobble:3,stick:2},label:'3 Cobble + 2 Sticks â†’ Pickaxe'},
  {result:'axe',    count:1, ingredients:{wood:3,stick:2}, label:'3 Wood + 2 Sticks â†’ Axe'},
  {result:'brick',  count:4, ingredients:{stone:4},        label:'4 Stone â†’ 4 Brick'},
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INVENTORY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// inv[i] = {id:string, count:number} or null
const INV_SIZE=27;
const inv=new Array(INV_SIZE).fill(null);

const hotbarSize=8;

// All mutable state hoisted to prevent TDZ errors
let mode='mine';
let mineTarget=null,mineProgress=0;
let attackCooldown=0;
let lmbHeld=false;
let gameStarted=false,lastMX=null,lastMY=null;
let invOpen=false,craftOpen=false;
let hotbarSlot=0;
let tt;

function addItem(id,count=1){
  // Try stack existing
  for(let i=0;i<INV_SIZE;i++){
    if(inv[i]&&inv[i].id===id&&inv[i].count<(ITEMS[id]?.stackSize||64)){
      const room=(ITEMS[id]?.stackSize||64)-inv[i].count;
      const add=Math.min(room,count);
      inv[i].count+=add; count-=add;
      if(count<=0){refreshInv();refreshHotbar();return true;}
    }
  }
  // Find empty
  for(let i=0;i<INV_SIZE;i++){
    if(!inv[i]){
      inv[i]={id,count:Math.min(count,ITEMS[id]?.stackSize||64)};
      count-=inv[i].count;
      if(count<=0){refreshInv();refreshHotbar();return true;}
    }
  }
  refreshInv();refreshHotbar();
  return count<=0;
}

function hasItems(req){
  const tally={};
  for(let i=0;i<INV_SIZE;i++) if(inv[i]) tally[inv[i].id]=(tally[inv[i].id]||0)+inv[i].count;
  for(const [id,need] of Object.entries(req)) if((tally[id]||0)<need) return false;
  return true;
}

function removeItems(req){
  for(const [id,need] of Object.entries(req)){
    let left=need;
    for(let i=INV_SIZE-1;i>=0&&left>0;i--){
      if(inv[i]&&inv[i].id===id){
        const take=Math.min(inv[i].count,left);
        inv[i].count-=take; left-=take;
        if(inv[i].count<=0)inv[i]=null;
      }
    }
  }
  refreshInv();refreshHotbar();
}

// Start with basic items
addItem('dirt',10); addItem('grass',5); addItem('wood',3);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SCENE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas=document.getElementById('c');
const renderer=new THREE.WebGLRenderer({canvas,antialias:false});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,1));
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x7ec8e8);
scene.fog=new THREE.Fog(0x7ec8e8,18,45);
const camera=new THREE.PerspectiveCamera(80,innerWidth/innerHeight,0.05,60);
scene.add(new THREE.AmbientLight(0xffffff,0.75));
const sun=new THREE.DirectionalLight(0xffeebb,0.85);
sun.position.set(1,2,0.5).normalize(); scene.add(sun);

for(let i=0;i<10;i++){
  const m=new THREE.Mesh(
    new THREE.BoxGeometry(5+Math.random()*7,1,3+Math.random()*5),
    new THREE.MeshLambertMaterial({color:0xffffff,transparent:true,opacity:0.85})
  );
  m.position.set(Math.random()*60-6,22+Math.random()*5,Math.random()*60-6);
  m.userData.cloud=true; scene.add(m);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const W=48,H=24,D=48;
const world=new Int8Array(W*H*D).fill(-1);
const waterMesh=new THREE.InstancedMesh(
  new THREE.BoxGeometry(1,0.7,1),
  new THREE.MeshLambertMaterial({color:0x2255CC,transparent:true,opacity:0.6}),W*D);
waterMesh.count=0; waterMesh.frustumCulled=false; scene.add(waterMesh);

const iMeshes=BDEFS.map(b=>{
  const g=new THREE.BoxGeometry(1,1,1);
  const fc=b.colors.map(h=>new THREE.Color(h));
  const cols=[];
  for(let f=0;f<6;f++){const c=fc[f];for(let v=0;v<6;v++)cols.push(c.r,c.g,c.b);}
  g.setAttribute('color',new THREE.Float32BufferAttribute(cols,3));
  const im=new THREE.InstancedMesh(g,new THREE.MeshLambertMaterial({vertexColors:true}),W*H*D);
  im.count=0; im.frustumCulled=false; scene.add(im); return im;
});

function wi(x,y,z){return x*H*D+y*D+z}
function getB(x,y,z){if(x<0||x>=W||y<0||y>=H||z<0||z>=D)return -2; return world[wi(x,y,z)];}
function isSolid(x,y,z){const b=getB(x,y,z);return b===-2||b>=0;}
const _m4=new THREE.Matrix4();
function rebuild(){
  iMeshes.forEach(im=>{im.count=0;});
  for(let x=0;x<W;x++)for(let y=0;y<H;y++)for(let z=0;z<D;z++){
    const b=world[wi(x,y,z)];if(b<0)continue;
    _m4.makeTranslation(x+0.5,y+0.5,z+0.5);
    iMeshes[b].setMatrixAt(iMeshes[b].count++,_m4);
  }
  iMeshes.forEach(im=>{im.instanceMatrix.needsUpdate=true;});
}
function setBlock(x,y,z,b){if(x<0||x>=W||y<0||y>=H||z<0||z>=D)return;world[wi(x,y,z)]=b;rebuild();}

// Terrain
const SEA=7; const heightMap=new Int32Array(W*D);
function terrH(x,z){return 8+Math.round(Math.sin(x*0.3)*3+Math.cos(z*0.25)*2.5+Math.sin(x*0.6+z*0.4)*1.5+Math.cos(x*0.18+z*0.2)*2+Math.sin(x*0.1+z*0.08)*4);}
(function gen(){
  for(let x=0;x<W;x++)for(let z=0;z<D;z++)heightMap[x*D+z]=terrH(x,z);
  for(let x=0;x<W;x++)for(let z=0;z<D;z++){
    const top=heightMap[x*D+z],beach=top<=SEA+1;
    if(top>=0&&top<H)world[wi(x,top,z)]=beach?5:0;
    for(let y=Math.max(0,top-3);y<top&&y<H;y++)world[wi(x,y,z)]=beach?5:1;
    for(let y=0;y<Math.max(0,top-3)&&y<H;y++)world[wi(x,y,z)]=2;
  }
  [[8,10],[16,22],[36,12],[10,34],[38,30],[22,8],[28,40]].forEach(([tx,tz])=>{
    if(tx>=W||tz>=D)return;
    const th=heightMap[tx*D+tz]; if(th<=SEA+1)return;
    for(let i=1;i<=4;i++)if(th+i<H)world[wi(tx,th+i,tz)]=3;
    for(let dx=-2;dx<=2;dx++)for(let dz=-2;dz<=2;dz++)for(let dy=2;dy<=5;dy++){
      if(Math.abs(dx)+Math.abs(dz)+Math.abs(dy-3.5)<=3.8){
        const lx=tx+dx,ly=th+dy,lz=tz+dz;
        if(lx>=0&&lx<W&&ly>=0&&ly<H&&lz>=0&&lz<D&&world[wi(lx,ly,lz)]<0)world[wi(lx,ly,lz)]=4;
      }
    }
  });
  rebuild();
  let wc=0; const wm=new THREE.Matrix4();
  for(let x=0;x<W;x++)for(let z=0;z<D;z++){
    if(heightMap[x*D+z]<SEA){wm.makeTranslation(x+0.5,SEA-0.15,z+0.5);waterMesh.setMatrixAt(wc++,wm);}
  }
  waterMesh.count=wc; waterMesh.instanceMatrix.needsUpdate=true;
})();

function groundY(x,z){
  const xi=Math.max(0,Math.min(W-1,Math.floor(x))),zi=Math.max(0,Math.min(D-1,Math.floor(z)));
  for(let y=H-1;y>=0;y--) if(world[wi(xi,y,zi)]>=0) return y+1;
  return SEA+1;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAYER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const P={pos:new THREE.Vector3(W/2,12,D/2),vel:new THREE.Vector3(),yaw:0,pitch:0.2,
  onGround:false,R:0.28,H:1.62,EYE:1.52,SPD:5,JMP:8,hp:10,maxHp:10,dmgCooldown:0};
{const sy=groundY(W/2,D/2);P.pos.set(W/2,sy+0.1,D/2);}
function getLookDir(){return new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(P.pitch,P.yaw,0,'YXZ'));}

// DDA ray
function raycast(ox,oy,oz,dx,dy,dz,maxD){
  let x=Math.floor(ox),y=Math.floor(oy),z=Math.floor(oz);
  const sx=dx>0?1:-1,sy=dy>0?1:-1,sz=dz>0?1:-1;
  const tx=Math.abs(1/(dx||1e-10)),ty=Math.abs(1/(dy||1e-10)),tz=Math.abs(1/(dz||1e-10));
  let mx=(dx>0?x+1-ox:ox-x)*tx,my=(dy>0?y+1-oy:oy-y)*ty,mz=(dz>0?z+1-oz:oz-z)*tz;
  let face=[0,0,0];
  for(let i=0;i<80;i++){
    const b=getB(x,y,z);
    if(b>=0)return{x,y,z,b,nx:face[0],ny:face[1],nz:face[2]};
    if(mx<my&&mx<mz){if(mx>maxD)break;mx+=tx;x+=sx;face=[-sx,0,0];}
    else if(my<mz){if(my>maxD)break;my+=ty;y+=sy;face=[0,-sy,0];}
    else{if(mz>maxD)break;mz+=tz;z+=sz;face=[0,0,-sz];}
  }
  return null;
}

// Collision
function boxCollides(pos){
  const r=P.R,h=P.H;
  for(const bx of[Math.floor(pos.x-r),Math.floor(pos.x+r)])
  for(const by of[Math.floor(pos.y),Math.floor(pos.y+h*0.5),Math.floor(pos.y+h-0.01)])
  for(const bz of[Math.floor(pos.z-r),Math.floor(pos.z+r)])
    if(isSolid(bx,by,bz))return true;
  return false;
}

function physics(dt){
  const TURN=2.4;
  if(keys['ArrowLeft'])P.yaw+=TURN*dt;
  if(keys['ArrowRight'])P.yaw-=TURN*dt;
  const fwd=new THREE.Vector3(-Math.sin(P.yaw),0,-Math.cos(P.yaw));
  const rgt=new THREE.Vector3(Math.cos(P.yaw),0,-Math.sin(P.yaw));
  const mv=new THREE.Vector3();
  if(keys['KeyW']||keys['ArrowUp'])   mv.addScaledVector(fwd,1);
  if(keys['KeyS']||keys['ArrowDown']) mv.addScaledVector(fwd,-1);
  if(keys['KeyA'])                     mv.addScaledVector(rgt,-1);
  if(keys['KeyD'])                     mv.addScaledVector(rgt,1);
  if(mv.lengthSq()>0)mv.normalize().multiplyScalar(P.SPD);
  if(keys['Space']&&P.onGround){P.vel.y=P.JMP;P.onGround=false;}
  P.vel.y=Math.max(P.vel.y-22*dt,-30);
  const np=P.pos.clone();
  np.x+=mv.x*dt; if(!boxCollides(np))P.pos.x=np.x; np.x=P.pos.x;
  np.z=P.pos.z+mv.z*dt; if(!boxCollides(np))P.pos.z=np.z; np.z=P.pos.z;
  np.y=P.pos.y+P.vel.y*dt;
  if(!boxCollides(np)){P.pos.y=np.y;P.onGround=false;}
  else{if(P.vel.y<0)P.onGround=true;P.vel.y=0;}
  P.pos.x=Math.max(P.R+0.1,Math.min(W-P.R-0.1,P.pos.x));
  P.pos.z=Math.max(P.R+0.1,Math.min(D-P.R-0.1,P.pos.z));
  if(P.pos.y<0){P.pos.y=0;P.vel.y=0;P.onGround=true;}
  if(P.dmgCooldown>0)P.dmgCooldown-=dt;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENTITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const entities=[];
function mkMat(hex){return new THREE.MeshLambertMaterial({color:new THREE.Color(hex)});}

function spawnEntity(type,x,z){
  const ECFG={
    cow:    {hc:'#DDD',bc:'#CCC',lc:'#AAA',hs:0.55,bs:[0.9,0.7,0.5],ls:0.18,lh:0.45,spd:1.2,hp:10,hostile:false,drops:[{id:'meat',min:1,max:3}]},
    pig:    {hc:'#F4A0A0',bc:'#F4A0A0',lc:'#E08080',hs:0.45,bs:[0.8,0.6,0.45],ls:0.16,lh:0.35,spd:1.4,hp:10,hostile:false,drops:[{id:'meat',min:1,max:2}]},
    chicken:{hc:'#FFF',bc:'#FFF',lc:'#FFB300',hs:0.32,bs:[0.5,0.4,0.35],ls:0.1,lh:0.28,spd:1.6,hp:4,hostile:false,drops:[{id:'feather',min:1,max:2}]},
    zombie: {hc:'#4a9a5a',bc:'#2d6e3e',lc:'#1a4a2e',hs:0.5,bs:[0.7,0.8,0.4],ls:0.17,lh:0.5,spd:1.8,hp:20,hostile:true,atk:2,drops:[{id:'bone',min:0,max:2}]},
  }[type];
  if(!ECFG)return;

  const gy=groundY(x,z);
  const grp=new THREE.Group();
  const head=new THREE.Mesh(new THREE.BoxGeometry(ECFG.hs,ECFG.hs,ECFG.hs),mkMat(ECFG.hc));
  const body=new THREE.Mesh(new THREE.BoxGeometry(...ECFG.bs),mkMat(ECFG.bc));
  const legs=[0,1,2,3].map(()=>new THREE.Mesh(new THREE.BoxGeometry(ECFG.ls,ECFG.lh,ECFG.ls),mkMat(ECFG.lc)));

  const bh=ECFG.bs[1],lh=ECFG.lh,hs=ECFG.hs,bw=ECFG.bs[0],bd=ECFG.bs[2];
  body.position.set(0,lh+bh/2,0);
  head.position.set(0,lh+bh+hs/2,0);
  const lxo=bw*0.28,lzo=bd*0.28;
  legs[0].position.set(-lxo,lh/2,-lzo);
  legs[1].position.set( lxo,lh/2,-lzo);
  legs[2].position.set(-lxo,lh/2, lzo);
  legs[3].position.set( lxo,lh/2, lzo);

  if(type==='zombie'){
    const em=mkMat('#ff2222');
    [-0.12,0.12].forEach(ex=>{
      const eye=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.08,0.02),em);
      eye.position.set(ex,lh+bh+hs*0.55,hs/2+0.01);
      grp.add(eye);
    });
    // Raised arms
    const arm=new THREE.Mesh(new THREE.BoxGeometry(ECFG.ls,ECFG.lh*0.8,ECFG.ls),mkMat(ECFG.bc));
    arm.position.set(bw*0.6,lh+bh*0.7,0.25); arm.rotation.x=-1.2;
    grp.add(arm);
  }

  // Health bar (thin box above head)
  const hbBg=new THREE.Mesh(new THREE.BoxGeometry(0.8,0.06,0.06),mkMat('#333'));
  const hbFg=new THREE.Mesh(new THREE.BoxGeometry(0.8,0.06,0.07),mkMat('#22cc22'));
  hbBg.position.set(0,lh+bh+hs+0.2,0);
  hbFg.position.copy(hbBg.position);
  hbFg.position.z+=0.01;
  grp.add(hbBg,hbFg);
  grp.add(head,body,...legs);
  scene.add(grp);

  const e={type,grp,head,body,legs,hbFg,cfg:ECFG,
    pos:new THREE.Vector3(x,gy,z),vel:new THREE.Vector3(),
    hp:ECFG.hp,maxHp:ECFG.hp,yaw:Math.random()*Math.PI*2,
    wanderTimer:Math.random()*2,onGround:false,dead:false,legPhase:0,hitFlash:0};
  grp.position.copy(e.pos);
  entities.push(e);
  return e;
}

function boxCollideEnt(pos,r,h){
  for(const bx of[Math.floor(pos.x-r),Math.floor(pos.x+r)])
  for(const by of[Math.floor(pos.y),Math.floor(pos.y+h*0.5),Math.floor(pos.y+h-0.01)])
  for(const bz of[Math.floor(pos.z-r),Math.floor(pos.z+r)])
    if(isSolid(bx,by,bz))return true;
  return false;
}

function killEntity(e){
  e.dead=true;
  scene.remove(e.grp);
  // Drop loot
  e.cfg.drops.forEach(d=>{
    const cnt=d.min+Math.floor(Math.random()*(d.max-d.min+1));
    if(cnt>0){addItem(d.id,cnt);toast(`+${cnt} ${ITEMS[d.id].icon} ${ITEMS[d.id].name}`);}
  });
}

function updateEntities(dt){
  for(const e of entities){
    if(e.dead)continue;
    e.wanderTimer-=dt;
    if(e.hitFlash>0){
      e.hitFlash-=dt;
      const col=e.hitFlash>0?0xff0000:0x000000;
      e.grp.traverse(c=>{if(c.isMesh&&c.material&&c.material.emissive)c.material.emissive.set(col);});
    }

    // AI
    const toP=new THREE.Vector3(P.pos.x-e.pos.x,0,P.pos.z-e.pos.z);
    const dist=toP.length();
    if(e.cfg.hostile){
      if(dist<22&&dist>0.8){
        toP.normalize();
        e.yaw=Math.atan2(-toP.x,-toP.z);
        e.vel.x=toP.x*e.cfg.spd; e.vel.z=toP.z*e.cfg.spd;
      } else if(dist<=0.8){
        e.vel.x=0;e.vel.z=0;
        if(P.dmgCooldown<=0){
          P.hp=Math.max(0,P.hp-(e.cfg.atk||1));
          P.dmgCooldown=1.0; updateHP();
          flashDmg();
          toast('âš  Zombie hit you! -'+e.cfg.atk+'â¤');
          if(P.hp<=0)die();
        }
      } else {
        // Always wander - never stand still
        if(e.wanderTimer<=0){
          e.yaw=Math.random()*Math.PI*2;
          e.wanderTimer=1+Math.random()*2;
        }
        e.vel.x=-Math.sin(e.yaw)*e.cfg.spd*0.6;
        e.vel.z=-Math.cos(e.yaw)*e.cfg.spd*0.6;
      }
    } else {
      if(e.wanderTimer<=0){
        if(Math.random()<0.35){e.vel.x=0;e.vel.z=0;}
        else{e.yaw=Math.random()*Math.PI*2;e.vel.x=-Math.sin(e.yaw)*e.cfg.spd;e.vel.z=-Math.cos(e.yaw)*e.cfg.spd;}
        e.wanderTimer=1.5+Math.random()*3;
      }
    }

    // Gravity + collision
    e.vel.y=Math.max(e.vel.y-18*dt,-20);
    const r=0.3,h=e.cfg.lh+e.cfg.bs[1]+e.cfg.hs;
    const np=e.pos.clone();
    np.x+=e.vel.x*dt; if(!boxCollideEnt(np,r,h))e.pos.x=np.x; else{e.vel.x*=-0.5;np.x=e.pos.x;}
    np.z=e.pos.z+e.vel.z*dt; if(!boxCollideEnt(np,r,h))e.pos.z=np.z; else{e.vel.z*=-0.5;np.z=e.pos.z;}
    np.y=e.pos.y+e.vel.y*dt;
    if(!boxCollideEnt(np,r,h)){e.pos.y=np.y;e.onGround=false;}
    else{if(e.vel.y<0)e.onGround=true;e.vel.y=0;}
    e.pos.x=Math.max(1,Math.min(W-1,e.pos.x));
    e.pos.z=Math.max(1,Math.min(D-1,e.pos.z));
    if(e.pos.y<0){e.pos.y=0;e.vel.y=0;e.onGround=true;}

    // Leg anim
    const spd=Math.hypot(e.vel.x,e.vel.z);
    if(spd>0.05)e.legPhase+=dt*spd*4;
    const sw=Math.sin(e.legPhase)*0.45;
    e.legs[0].rotation.x=sw; e.legs[1].rotation.x=-sw;
    e.legs[2].rotation.x=-sw; e.legs[3].rotation.x=sw;

    // Health bar scale
    const hpRatio=e.hp/e.maxHp;
    e.hbFg.scale.x=Math.max(0.01,hpRatio);
    e.hbFg.position.x=(hpRatio-1)*0.4;

    e.grp.position.copy(e.pos);
    e.grp.rotation.y=e.yaw;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODES & INTERACTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// (hoisted above)

function setMode(m){
  mode=m;
  document.querySelectorAll('.modeBtn').forEach(b=>b.classList.remove('active'));
  document.getElementById('mode-'+m).classList.add('active');
  mineTarget=null; mineProgress=0;
  document.getElementById('mineBar').style.display='none';
  toast({mine:'â› MINE mode â€” hold LMB to mine blocks',fight:'âš” FIGHT mode â€” click LMB to attack entities',build:'ğŸ§± BUILD mode â€” LMB places selected block'}[m]);
}

// Hold LMB state
// (hoisted above)

// Get entity hit by ray - proper AABB test along look direction
function raycastEntity(maxD=5){
  const ey=new THREE.Vector3(P.pos.x,P.pos.y+P.EYE,P.pos.z);
  const d=getLookDir();
  let best=null,bestDist=maxD;
  for(const e of entities){
    if(e.dead)continue;
    // Entity AABB center is ~1 block above its pos base
    const ec=new THREE.Vector3(e.pos.x, e.pos.y+0.8, e.pos.z);
    const toE=new THREE.Vector3().subVectors(ec,ey);
    const along=toE.dot(d);
    if(along<-0.5||along>maxD)continue;
    // Closest point on ray to entity center
    const t=Math.max(0,along);
    const closest=ey.clone().addScaledVector(d,t);
    const dist=closest.distanceTo(ec);
    // Hit radius 1.1 - generous so it actually works
    if(dist<1.1&&t<bestDist){bestDist=t;best=e;}
  }
  return best;
}

function getHeldItem(){
  // hotbar slot 0..hotbarSize-1
  return inv[hotbarSlot]?ITEMS[inv[hotbarSlot].id]:null;
}

function doAttack(){
  if(attackCooldown>0)return;
  attackCooldown=0.5;
  const target=raycastEntity(5);
  if(target){
    const held=getHeldItem();
    let dmg=held?.dmg||1;
    target.hp-=dmg;
    target.hitFlash=0.3;
    // Knockback away from player
    const kbDir=new THREE.Vector3(target.pos.x-P.pos.x,0.3,target.pos.z-P.pos.z).normalize();
    target.vel.x+=kbDir.x*5; target.vel.y+=kbDir.y*4; target.vel.z+=kbDir.z*5;
    toast('Hit '+target.type+' -'+dmg+'â¤ ('+Math.max(0,target.hp)+'/'+target.maxHp+')');
    if(target.hp<=0){killEntity(target);}
  } else {
    toast('Nothing in range to hit!');
  }
}


// Eat held food item
function doEat(){
  const item=inv[hotbarSlot];
  if(!item)return;
  const idef=ITEMS[item.id];
  if(!idef||!idef.heal){toast('That is not food!');return;}
  if(P.hp>=P.maxHp){toast('Already full health!');return;}
  P.hp=Math.min(P.maxHp,P.hp+idef.heal);
  item.count--;
  if(item.count<=0)inv[hotbarSlot]=null;
  updateHP(); refreshHotbar();
  toast('Ate '+idef.icon+' '+idef.name+' +'+idef.heal+'â¤');
}
function doMine(hit,dt){
  if(!hit)return;
  const key=`${hit.x},${hit.y},${hit.z}`;
  if(!mineTarget||mineTarget.key!==key){mineTarget={key,...hit};mineProgress=0;}
  const bdef=BDEFS[hit.b];
  const held=getHeldItem();
  let speed=1;
  if(held?.mineSpeed)speed=held.mineSpeed;
  mineProgress+=dt*speed;
  const pct=Math.min(1,mineProgress/bdef.hardness);
  document.getElementById('mineBar').style.display='block';
  document.getElementById('mineFill').style.width=(pct*100)+'%';
  if(mineProgress>=bdef.hardness){
    setBlock(hit.x,hit.y,hit.z,-1);
    if(bdef.drop){addItem(bdef.drop,1);toast(`+1 ${ITEMS[bdef.drop]?.icon||''} ${ITEMS[bdef.drop]?.name||bdef.drop}`);}
    mineTarget=null;mineProgress=0;
    document.getElementById('mineBar').style.display='none';
  }
}

function doPlace(hit){
  if(!hit)return;
  const nx=hit.x+hit.nx,ny=hit.y+hit.ny,nz=hit.z+hit.nz;
  const r=P.R,h=P.H,px=P.pos.x,py=P.pos.y,pz=P.pos.z;
  if(nx<px+r&&nx+1>px-r&&ny<py+h&&ny+1>py&&nz<pz+r&&nz+1>pz-r)return;
  // Use hotbar item if it's a block
  const item=inv[hotbarSlot];
  if(!item){toast('No block selected!');return;}
  const idef=ITEMS[item.id];
  if(!idef||idef.block<0){toast('That item is not placeable!');return;}
  setBlock(nx,ny,nz,idef.block);
  item.count--;
  if(item.count<=0)inv[hotbarSlot]=null;
  refreshHotbar();
  toast(`Placed ${idef.icon} ${idef.name}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const keys={};
// (hoisted above)

document.addEventListener('keydown',e=>{
  // Only capture arrow/space keys when game is active to not block page scrolling
  if(gameStarted&&!invOpen&&!craftOpen){
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code))e.preventDefault();
  }
  keys[e.code]=true;
  if(!gameStarted)return;
  const n=+e.key;
  if(n>=1&&n<=hotbarSize){hotbarSlot=n-1;refreshHotbar();}
  if(e.code==='KeyE'){invOpen?closeInv():openInv();}
  if(e.code==='KeyC'){craftOpen?closeCraft():openCraft();}
  if(e.code==='KeyF'){const modes=['mine','fight','build'];setMode(modes[(modes.indexOf(mode)+1)%3]);}
  if(e.code==='KeyR'){doEat();}
});
document.addEventListener('keyup',e=>{keys[e.code]=false;});
document.addEventListener('contextmenu',e=>e.preventDefault());

window.addEventListener('mousemove',e=>{
  if(!gameStarted||invOpen||craftOpen)return;
  if(lastMX===null){lastMX=e.clientX;lastMY=e.clientY;return;}
  P.yaw-=(e.clientX-lastMX)*0.003;
  P.pitch=Math.max(-1.4,Math.min(1.4,P.pitch-(e.clientY-lastMY)*0.003));
  lastMX=e.clientX;lastMY=e.clientY;
});

canvas.addEventListener('mousedown',e=>{
  if(!gameStarted||invOpen||craftOpen)return;
  if(e.button===0){lmbHeld=true;
    if(mode==='fight')doAttack();
    if(mode==='build'){
      const ey=new THREE.Vector3(P.pos.x,P.pos.y+P.EYE,P.pos.z);
      const d=getLookDir(); const hit=raycast(ey.x,ey.y,ey.z,d.x,d.y,d.z,6);
      doPlace(hit);
    }
  }
  if(e.button===2){
    const item=inv[hotbarSlot];
    const idef=item?ITEMS[item.id]:null;
    if(idef&&idef.heal){
      doEat();
    } else {
      const ey=new THREE.Vector3(P.pos.x,P.pos.y+P.EYE,P.pos.z);
      const d=getLookDir(); const hit=raycast(ey.x,ey.y,ey.z,d.x,d.y,d.z,6);
      doPlace(hit);
    }
  }
});
canvas.addEventListener('mouseup',e=>{if(e.button===0){lmbHeld=false;mineTarget=null;mineProgress=0;document.getElementById('mineBar').style.display='none';}});

canvas.addEventListener('wheel',e=>{
  if(!gameStarted)return;
  hotbarSlot=(hotbarSlot+(e.deltaY>0?1:-1)+hotbarSize)%hotbarSize;refreshHotbar();
},{passive:true});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// (hoisted above)

function refreshHotbar(){
  const hb=document.getElementById('hotbar'); hb.innerHTML='';
  for(let i=0;i<hotbarSize;i++){
    const s=document.createElement('div');
    s.className='slot'+(i===hotbarSlot?' active':'');
    const item=inv[i];
    s.innerHTML=`<span class="slot-key">${i+1}</span>`+
      (item?`<span class="slot-icon">${ITEMS[item.id]?.icon||'?'}</span>${item.count>1?`<span class="slot-count">${item.count}</span>`:''}`:
      `<span style="font-size:10px;color:#333">Â·</span>`);
    s.onclick=()=>{hotbarSlot=i;refreshHotbar();};
    hb.appendChild(s);
  }
}
refreshHotbar();

function openInv(){
  invOpen=true;
  document.getElementById('inventory').style.display='flex';
  refreshInvGrid();
}
function closeInv(){
  invOpen=false;
  document.getElementById('inventory').style.display='none';
  lastMX=null;lastMY=null;
}
function refreshInvGrid(){
  const grid=document.getElementById('invGrid'); grid.innerHTML='';
  for(let i=0;i<INV_SIZE;i++){
    const s=document.createElement('div');
    s.className='inv-slot';
    const item=inv[i];
    if(item){
      const idef=ITEMS[item.id];
      s.innerHTML=`${idef?.icon||'?'}${item.count>1?`<span class="inv-count">${item.count}</span>`:''}`;
      s.title=(idef?.heal?'Right-click to eat Â· ':'')+'Click to hotbar Â· '+idef?.name+' x'+item.count;
      // Left-click: move to hotbar
      s.onclick=()=>{
        const hi=inv.findIndex((v,j)=>j<hotbarSize&&!v);
        if(hi>=0){inv[hi]=item;inv[i]=null;}
        else{inv[hotbarSlot]=item;inv[i]=null;} // replace active slot
        refreshInvGrid();refreshHotbar();
      };
      // Right-click: eat food directly from inventory
      s.addEventListener('contextmenu',ev=>{
        ev.preventDefault();ev.stopPropagation();
        if(!idef?.heal){toast('Not food!');return;}
        if(P.hp>=P.maxHp){toast('Already full health!');return;}
        P.hp=Math.min(P.maxHp,P.hp+idef.heal);
        item.count--;
        if(item.count<=0)inv[i]=null;
        updateHP();refreshInvGrid();refreshHotbar();
        toast('Ate '+idef.icon+' '+idef.name+' +'+idef.heal+'â¤');
      });
    } else {
      s.style.cursor='default';
    }
    grid.appendChild(s);
  }
}
function refreshInv(){if(invOpen)refreshInvGrid();}

function openCraft(){
  craftOpen=true;
  document.getElementById('crafting').style.display='flex';
  refreshRecipes();
}
function closeCraft(){
  craftOpen=false;
  document.getElementById('crafting').style.display='none';
  lastMX=null;lastMY=null;
}
function refreshRecipes(){
  const list=document.getElementById('recipesList'); list.innerHTML='';
  RECIPES.forEach(r=>{
    const can=hasItems(r.ingredients);
    const row=document.createElement('div');
    row.className='recipe-row'+(can?'':' disabled');
    const costStr=Object.entries(r.ingredients).map(([id,n])=>`${n}x ${ITEMS[id]?.icon||id}${ITEMS[id]?.name||id}`).join(' + ');
    row.innerHTML=`<span class="recipe-icon">${ITEMS[r.result]?.icon||'?'}</span>
      <div class="recipe-info"><div class="recipe-name">${ITEMS[r.result]?.name||r.result}</div>
      <div class="recipe-cost">${costStr}</div></div>
      <span class="recipe-result">â†’ ${r.count}x</span>`;
    if(can){
      row.onclick=()=>{
        removeItems(r.ingredients);
        addItem(r.result,r.count);
        toast(`âœ… Crafted ${r.count}x ${ITEMS[r.result].icon} ${ITEMS[r.result].name}!`);
        refreshRecipes();
      };
    }
    list.appendChild(row);
  });
}

function updateHP(){
  const el=document.getElementById('hp'); el.innerHTML='';
  for(let i=0;i<P.maxHp;i++){
    const h=document.createElement('span');
    h.className='heart';h.textContent=i<P.hp?'â¤ï¸':'ğŸ–¤';el.appendChild(h);
  }
}
updateHP();

function flashDmg(){
  const f=document.getElementById('dmgFlash');
  f.classList.add('flash');
  setTimeout(()=>f.classList.remove('flash'),150);
}

function die(){document.getElementById('deathScreen').style.display='flex';gameStarted=false;}
function respawn(){
  P.hp=P.maxHp;updateHP();
  const sy=groundY(W/2,D/2);P.pos.set(W/2,sy+0.1,D/2);P.vel.set(0,0,0);
  document.getElementById('deathScreen').style.display='none';
  gameStarted=true;lastMX=null;lastMY=null;toast('Respawned!');
}

// (hoisted above)
function toast(m){const t=document.getElementById('toast');t.textContent=m;t.style.display='block';clearTimeout(tt);tt=setTimeout(()=>t.style.display='none',1800);}

function startGame(){
  document.getElementById('blocker').style.display='none';
  gameStarted=true;lastMX=null;lastMY=null;
  toast('â› MINE mode active â€” hold LMB on blocks to mine!');
}

// Spawn entities
let sp=0;
for(let a=0;a<800&&sp<12;a++){
  const ax=3+Math.random()*(W-6),az=3+Math.random()*(D-6);
  const th=heightMap[Math.floor(ax)*D+Math.floor(az)];
  if(th>SEA+1&&th<H-3){spawnEntity(['cow','pig','chicken','cow','pig'][sp%5],ax,az);sp++;}
}
let zs=0;
for(let a=0;a<800&&zs<6;a++){
  const zx=3+Math.random()*(W-6),zz=3+Math.random()*(D-6);
  const th=heightMap[Math.floor(zx)*D+Math.floor(zz)];
  if(th>SEA+1&&th<H-3){spawnEntity('zombie',zx,zz);zs++;}
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let last=performance.now(),fr=0,fa=0;
(function loop(){
  requestAnimationFrame(loop);
  const now=performance.now(),dt=Math.min((now-last)/1000,0.05);last=now;
  fr++;fa+=dt;
  if(fa>=0.5){document.getElementById('fps').textContent=`FPS:${Math.round(fr/fa)}`;fr=0;fa=0;}

  if(gameStarted&&!invOpen&&!craftOpen){
    physics(dt);
    if(attackCooldown>0)attackCooldown-=dt;
    // Mine on hold
    if(lmbHeld&&mode==='mine'){
      const ey=new THREE.Vector3(P.pos.x,P.pos.y+P.EYE,P.pos.z);
      const d=getLookDir();
      const hit=raycast(ey.x,ey.y,ey.z,d.x,d.y,d.z,5);
      doMine(hit,dt);
    }
  }
  updateEntities(dt);

  scene.children.filter(c=>c.userData.cloud).forEach(c=>{c.position.x+=0.3*dt;if(c.position.x>W+8)c.position.x=-8;});
  waterMesh.material.opacity=0.5+0.1*Math.sin(now*0.002);

  const ey=P.pos.y+P.EYE;
  camera.position.set(P.pos.x,ey,P.pos.z);
  camera.rotation.order='YXZ';
  camera.rotation.y=P.yaw;
  camera.rotation.x=P.pitch;

  const d=getLookDir();
  const hit=raycast(P.pos.x,ey,P.pos.z,d.x,d.y,d.z,6);
  const entHit=raycastEntity(4);
  let lookStr='â€”';
  if(entHit)lookStr=`ğŸ¯ ${entHit.type} (${entHit.hp}hp)`;
  else if(hit)lookStr=`${BDEFS[hit.b].name}`;
  document.getElementById('look').textContent=lookStr;
  document.getElementById('pos').textContent=`${P.pos.x.toFixed(0)}/${P.pos.y.toFixed(0)}/${P.pos.z.toFixed(0)}`;

  renderer.render(scene,camera);
})();

window.addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});
</script>
</body>
</html>
